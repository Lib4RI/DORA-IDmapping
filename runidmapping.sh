#!/bin/sh

###
 # Copyright (c) 2017 d-r-p <d-r-p@users.noreply.github.com>
 #
 # Permission to use, copy, modify, and distribute this software for any
 # purpose with or without fee is hereby granted, provided that the above
 # copyright notice and this permission notice appear in all copies.
 #
 # THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 # WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 # MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 # ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 # WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 # ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 # OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
###

### define programs

SED="/bin/sed"
CAT="/bin/cat"
RM="/bin/rm"
DATE="/bin/date"
PYTHON="/usr/bin/python"
CRONTAB="/usr/bin/crontab"
MKTEMP="/bin/mktemp"

THIS="`echo "$0" | $SED 's/.*\/\([^\/]*\)/\1/'`"

PWD_ESC="`echo "$PWD" | $SED 's|/|\\\\/|g;'`"
THIS_FULLPATH="`echo "$0" | $SED "/^\// ! s/^/$PWD_ESC\//;"`" # actually, do yourself a favour and invoke $THIS _always_ via full path!
FULLPATH="`echo "$THIS_FULLPATH" | $SED 's/[^\/]*$//; s/\/$//;'`"

IDMAPPING="./idmapping.py" # actually, do yourself a favour and define $IDMAPPING with full path!
if [ "`echo "$IDMAPPING" | $SED 's/^\(.\).*$/\1/'`" != "/" ]
then
  IDMAPPING_FULLPATH="$FULLPATH/$IDMAPPING"
else
  IDMAPPING_FULLPATH="$IDMAPPING"
fi

### define local constants [edit this part only, if implementing elsewhere; NB: if you edit this, or invoke the script differently, you will have to manually clean the crontab!!!]

IDMAPPINGSETUPFILE="./idmappingsetup.xml" # setup file for your subsite; actually, do yourself a favour and define $IDMAPPINGSETUPFILE with full path!

if [ "`echo "$IDMAPPINGSETUPFILE" | $SED 's/^\(.\).*$/\1/'`" != "/" ] # [DO NOT EDIT]
then # [DO NOT EDIT]
  IDMAPPINGSETUPFILE_FULLPATH="$FULLPATH/$IDMAPPINGSETUPFILE" # [DO NOT EDIT]
else # [DO NOT EDIT]
  IDMAPPINGSETUPFILE_FULLPATH="$IDMAPPINGSETUPFILE" # [DO NOT EDIT]
fi # [DO NOT EDIT]

### define constants

MODE=0

QUIET=1
DONOTBACKUP=1

CRONDAY='today' # use 'today' if time before midnight, or 'tomorrow' if time after midnight
CRONDATEPARSESTRING='45 23 %_d %_m *' # set when the cronjob should be started; see crontab(5) and date(1) for the format (hint: format 'min hr day mon weekday' as '%_M %_H %_d %_m %u', where the underscore pads with spaces, '%u' can be replaced by '%w', and a star in any field means 'any'; e.g. '45 23 %_d %_m *' runs the cronjob at 23:45 of the $CRONDAY selected ('today' or 'tomorrow'))

### if we're past the cron-time, increase the cron-day

if [ "$CRONDAY" = 'today' ]
then
  CRONMIN="`echo $CRONDATEPARSESTRING | $SED 's/^[ ]*\([0-9]\+\).*$/\1/; s/^[0]*\(.*\)/\1/'`"
  CRONHR="`echo $CRONDATEPARSESTRING | $SED 's/^[ ]*[0-9]\+[ ]\+\([0-9]\+\).*$/\1/; s/^[0]*\(.*\)/\1/'`"
  NOWHR="`$DATE +'%H' | $SED 's/^[0]*\(.*\)/\1/'`"
  NOWMIN="`$DATE +'%M' | $SED 's/^[0]*\(.*\)/\1/'`"
  NOWMIN=$(($NOWMIN+1))
  if [ $CRONHR -le $NOWHR ] && [ $CRONMIN -le $NOWMIN ]
  then
    CRONDAY='tomorrow'
  fi
fi

### define help strings

USAGE="$THIS [-b] [-a|-c|-g] [-h] [-v]"
usage() {
  echo "$USAGE" >&2
  exit 1
}

HELP="\t-a\t Schedule the cronjob next 11:45pm
\t-b\t Make a backup of the generated file (transitively!)
\t-c\t Clean-up crontab (remove all references to executing $THIS)
\t-g\t Get the cron-command
\t-h\t Show this message
\t-v\t Be verbose (transitively!)"

### parse command line options

# getopts-parsing inspired by https://blog.mafr.de/2007/08/05/cmdline-options-in-shell-scripts/ ;
# see also, e.g., http://www.gnu.org/software/bash/manual/bashref.html#Bourne-Shell-Builtins

while getopts "abcghv" O
do
  case "$O" in
    a) # add a cronjob, scheduled next midnight
      if [ $MODE -ne 0 ]
      then
        echo "Error: -a, -c and -g are mutually exclusive!" >&2
        usage
      fi
      MODE=3
      ;;
    b) # backup the file generated by $IDMAPPING
      DONOTBACKUP=0
      ;;
    c) # clean up the crontab
      if [ $MODE -ne 0 ]
      then
        echo "Error: -a, -c and -g are mutually exclusive!" >&2
        usage
      fi
      MODE=2
      ;;
    g) # get the cron-command
      if [ $MODE -ne 0 ]
      then
        echo "Error: -a, -c and -g are mutually exclusive!" >&2
        usage
      fi
      MODE=1
      ;;
    h) # help
      echo "$USAGE"
      echo "$HELP"
      exit 0
      ;;
    v) # be verbose
      QUIET=0
      ;;
    \?) # unknown option, so show the usage and exit
      echo "Error: Unknown option -$O" >&2
      usage
      ;;
  esac
done

shift $(($OPTIND - 1))

if [ $# -ne 0 ]
then
  echo "Error: Did not expect any argument" >&2
  usage
fi

VOPT=""
if [ $QUIET -eq 0 ]
then
  VOPT=" -v"
fi

BOPT=""
if [ $DONOTBACKUP -eq 0 ]
then
  BOPT=" -b"
fi

### generate cron-command

CRONCMD="$THIS_FULLPATH$VOPT$BOPT; $THIS_FULLPATH$VOPT$BOPT -c"

### display cron-command if -g and exit

if [ $MODE -eq 1 ]
then
  echo "$CRONCMD"
  exit 0
fi

### define the cleanup and add handler

cleanaddcrontab() {
  if [ $# -gt 1 ]
  then
    echo "Internal error: Wrong number of arguments" >&2
    exit 1
  fi
  ADD="$1"
  if  [ "$ADD" != "" ] && [ "$ADD" != "0" ] &&  [ "$ADD" != "1" ]
  then
    echo "Internal error: Invalid argument" >&2
    exit 1
  fi
  LASTERR=0
  TMPFILE="`$MKTEMP -q`"
  LASTERR=$?
  if [ $LASTERR -ne 0 ]
  then
    echo "Error: Could not create temporary file" >&2
    return $LASTERR
  fi
  $CRONTAB -l > "$TMPFILE" 2>/dev/null # we ignore non-zero return values and stderr output, since get both if no crontab
  CRONCMD_ESCAPED="`echo "$CRONCMD" | $SED 's|/|\\\\/|g;' | $SED 's|\.|\\\\.|g;'`"
  $SED -i "/$CRONCMD_ESCAPED$/ d;" "$TMPFILE"
  LASTERR=$?
  if [ $LASTERR -ne 0 ]
  then
    echo "Error: Could not clean up '$TMPFILE'" >&2
    return $LASTERR
  fi
  if [ "$ADD" = "1" ]
  then
    echo "`$DATE -d "$CRONDAY" +"$CRONDATEPARSESTRING"` $CRONCMD" >> "$TMPFILE" # add a line to the cleaned up crontab
    LASTERR=$?
  fi
  if [ $LASTERR -ne 0 ]
  then
    echo "Error: Could not add a line to '$TMPFILE'" >&2
    return $LASTERR
  fi
  if [ "`$CAT "$TMPFILE"`" = "" ] # in pure cleanup mode, remove the crontab alltogether if there are no more cronjobs
  then
    $CRONTAB -r 2>/dev/null # we ignore non-zero return values and stderr output, since get both if no crontab
  else
    $CRONTAB "$TMPFILE"
    LASTERR=$?
  fi
  if [ $LASTERR -ne 0 ]
  then
    echo "Error: Could not install '$TMPFILE' as new crontab" >&2
    return $LASTERR
  fi
  $RM "$TMPFILE"
  LASTERR=$?
  if [ $LASTERR -ne 0 ]
  then
    echo "Error: Could not remove '$TMPFILE'" >&2
    return $LASTERR
  fi
  return $LASTERR
}

### clean up crontab if -c and exit

if [ $MODE -eq 2 ]
then
  cleanaddcrontab
  exit $?
fi

### add an entry in the crontab according to the defined schedule if -a (cleaning up old ones)

if [ $MODE -eq 3 ]
then
  cleanaddcrontab 1
  exit $?
fi

### execute $IDMAPPING, logging its output, and exit with the same error code

LOGFILE="`echo "$IDMAPPING_FULLPATH" | $SED 's/.py$//'`.log.`$DATE -u +'%Y%m%dT%H%M%SZ'`"

$PYTHON "$IDMAPPING_FULLPATH"$VOPT$BOPT -s "$IDMAPPINGSETUPFILE_FULLPATH" > "$LOGFILE" 2>&1

exit $?
